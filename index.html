<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/hello-world/" class="article-date">
  <time datetime="2019-01-08T02:25:38.210Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/hello-world/" data-id="cjqn5ydmr00060wuuwldlpt78" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-seamcarving" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/seamcarving/" class="article-date">
  <time datetime="2018-06-26T14:33:31.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Capriccio/">Capriccio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/seamcarving/">图像接缝剪裁SeamCarving的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  源码 <a href="https://github.com/Gaobx/SeamCarving" target="_blank" rel="noopener">https://github.com/Gaobx/SeamCarving</a>  </p>
<p>@Author  :  ydk &amp; gaojx</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li>使用seam-carving实现图像resize</li>
<li>使用seam-carving实现带保护protect的resize</li>
<li>使用seam-carving实现物体remove</li>
<li>人脸识别，进而对人脸进行保护</li>
<li>研究不同能量函数完成的seam-carving效果</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>使用事先定义好的能量函数，针对图像上每个像素点计算其对应能力值，然后使用动态规划算法寻找当前图片中能量最小的一条线，根据所需要实现功能的不同进行不同操作。</li>
<li>采用了两个不同的能量函数，一种是论文使用的基于灰度扫描计算梯度的E1-Error。另一种是RGB-Error，即对R，G，B三个色彩通道分别计算梯度，求和作为能量。</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>resize的删除部分<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/1.png" alt=""></li>
<li>resize的拉伸部分<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/2.png" alt=""></li>
<li>remove 标记（mask）<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/3.png" alt=""></li>
</ol>
<h3 id="功能及结果"><a href="#功能及结果" class="headerlink" title="功能及结果"></a>功能及结果</h3><ol>
<li>缩放效果图<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/4.png" alt=""><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/5.png" alt=""></li>
<li>Remove效果图<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/6.png" alt=""><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/7.png" alt=""></li>
<li>seams show<ul>
<li>我们通过记录seams_index，可以多次重放resize及remove的操作，并显示算法找到的能量线。<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/8.png" alt=""></li>
</ul>
</li>
<li>face detection<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/9.png" alt=""></li>
<li>指定区域保护（mask protect）<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/10.png" alt=""></li>
<li>指定区域擦除（mask remove）<ul>
<li>根据mask图想的标记部分对指定图像进行remove<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/11.png" alt=""></li>
<li>指定矩形框内的部分进行remove<img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/13.png" alt=""></li>
</ul>
</li>
<li>软件截图</li>
</ol>
<p><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/SeamCarving/14.png" alt="">  </p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><pre><code>\[1\] Daniel Vaquero, et al. &quot;A survey of image retargeting techniques,&quot; Proc. SPIE 7798, Applications of Digital Image Processing XXXIII, 779814 (7 September 2010).
</code></pre><h3 id="源码参考"><a href="#源码参考" class="headerlink" title="源码参考"></a>源码参考</h3><ol>
<li><a href="https://github.com/vivianhylee/seam-carving" target="_blank" rel="noopener">https://github.com/vivianhylee/seam-carving</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/26/seamcarving/" data-id="cjqn5ydn0000h0wuujr1me38h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SeamCarving/">SeamCarving</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sklearn-predict-typhoon" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/sklearn-predict-typhoon/" class="article-date">
  <time datetime="2018-05-06T09:04:26.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataAnalysis/">DataAnalysis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/sklearn-predict-typhoon/">使用Sklearn训练模型预测台风路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  运用Sklearn的多种线性回归策略提高台风路径预测的准确性</p>
<hr>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul>
<li>使用Sklearn中线性回归、岭回归、ElasticNet回归以及Lasso回归模型对台风路径数据进行训练、预测，进行误差分析，并比较各个模型的优劣。</li>
<li>比较训练数据量对结果准确性的影响。</li>
<li>找出预测台风路径最优的回归模型，并使用模型对目标数据进行预测。</li>
</ul>
<h3 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h3><ul>
<li><a href="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/typhoon.dat" target="_blank" rel="noopener">typhoon.dat (500条训练数据集)</a></li>
<li><a href="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/typhoon200Test.dat" target="_blank" rel="noopener">typhoon200Test.dat (200条测试数据集)</a></li>
</ul>
<p>台风训练数据typhoon.dat, 共计500条，共18列，前16列为预报因子，最后2列分别是经纬度。 每行数据是间隔12个小时采集到的台风预报因子，数据的任务是预测台风的路径，即预测台风的经纬度，最后两列的值。 LON .V1： 起报时刻经度 lon+00 LON .V2： 起报时刻前12小时纬向移速 vlat-12 LON .V3： 起报时刻前24小时纬向移速 vlat-24（可能是经向） LON .V4： 起报时刻前24 小时所在经度 lon-24 LON .V5： 起报时刻前12 小时至前24小时纬向移速 vlat-24 LON .V6： 起报时刻与前12小时的经度差 (lon+00)-(lon-12) LON .V7： 起报时刻前6 小时所在经度 lon-06 LON .V8： 起报时刻前18 小时所在经度 lon-18 Lat.v9: 起报时刻纬度 lat+00 Lat.v10: 起报时刻前12小时经向移速 vlon-12 Lat.v11: 起报时刻前24小时经向移速的平方 (vlon-24)^2 Lat.v12: 起报时刻前12 小时所在纬度 lat-12 Lat.v13: 起报时刻与前24小时的经度差 (lon+00)-(lon-24) Lat.v14: 起报时刻前6 小时所在纬度 lat-06 Lat.v15: 起报时刻前18 小时所在纬度 lat-18 Lat.v16: 起报时刻前6 小时地面附近最大风速 wind-06 LON . t： 要预报的24小时后的经度（预报量） lon+24 Lat.t: 要预报的24小时后的纬度（预报量） lat+24 台风测试数据为 typhoon200Test.dat，共计200条，每条有16列预报因子，与训练数据的前16列数据格式顺序相同，但是没有最后的两列经纬度数据。 测试的任务就是对这200条台风数据预测每条记录的经度和纬度值。  </p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（分析过程代码见最后）</p>
<h4 id="首先分析一下各个回归模型训练数据量对预测结果准确性的影响。"><a href="#首先分析一下各个回归模型训练数据量对预测结果准确性的影响。" class="headerlink" title="首先分析一下各个回归模型训练数据量对预测结果准确性的影响。"></a>首先分析一下各个回归模型训练数据量对预测结果准确性的影响。</h4><p><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/1.png" alt=""> 上图是训练样本量对各个模型预测结果与真实结果的距离误差的影响。其中，横坐标是训练数据集的大小，纵坐标是真实的经纬度与预测的经纬度之间的距离。 由图可见，随着训练数据集中数据数量的增多，预测误差是逐渐减小的。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/2.png" alt=""> 上图是训练样本量对各个模型预测结果与真实结果的经纬度误差的影响。其中，横坐标是训练数据集的大小，纵坐标是真实的经纬度与预测的经纬度之间的误差大小。 由图亦可看出，随着训练数据集中数据数量的增多，预测误差是逐渐减小的。并且各个模型预测纬度的误差要小于对经度进行预测的误差。  </p>
<h4 id="使用50到300个预测样本分析不同的回归模型对台风路径预测误差的影响。"><a href="#使用50到300个预测样本分析不同的回归模型对台风路径预测误差的影响。" class="headerlink" title="使用50到300个预测样本分析不同的回归模型对台风路径预测误差的影响。"></a>使用50到300个预测样本分析不同的回归模型对台风路径预测误差的影响。</h4><p><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/3.png" alt=""> 上图是截取了训练样本数据量在50到300时预测的距离误差随训练数据量的变化趋势。 由图可见，在训练样本数据量稍大的情况下，岭回归与线性回归对台风路径的预测的误差较小。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/4.png" alt=""> 上图是截取了训练样本数据量在50到300时预测的经纬度误差随训练数据量的变化趋势。 由图可见，总体来说，各个回归模型对台风路径纬度的预测误差要小于对经度的预测误差。 在训练样本数据量稍大的情况下，岭回归对台风路径经度的预测的误差相对较小，线性回归对台风路径纬度的预测的误差相对较小。  </p>
<hr>
<p>由上述分析可知，在此数量级的训练样本下，线性回归对纬度的预测要较为准确，而岭回归对经度的预测较为准确。所以，可以对台风路径的经纬度分别使用这两种回归模型进行预测。 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/5.png" alt=""> 上图是训练样本量对预测经纬度与真实经纬度之间相关系数的影响。由图可见，在数据量为150到300之间时，岭回归对经度的预测结果与真实结果相关性最强，线性回归对纬度的预测结果与真实结果相关性最强。 所以在此实验中，可以使用岭回归来预测台风路径的经度值，使用线性回归来预测台风路径的纬度值。  </p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/6.png" alt=""> 上图中红线是使用岭回归来预测台风路径的经度值，使用线性回归来预测台风路径的纬度值，进而得到的距离误差。 可见，采用此方法预测在数据量大于150时要比其他方法准确。 所以，本实验最终使用岭回归来预测台风路径的经度值，使用线性回归来预测台风路径的纬度值，对200条测试数据进行预测。  </p>
<h4 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h4><p><a href="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/Sklearn-typhoon/typhoon200Results.dat" target="_blank" rel="noopener">typhoon200Results.dat</a>  </p>
<h4 id="预测代码"><a href="#预测代码" class="headerlink" title="预测代码"></a>预测代码</h4><p>from __future__ import division<br>import os, sys<br>import numpy as np<br># from numpy import <em><br>from sklearn import linear_model<br>from math import </em></p>
<p>import pandas as pd<br>from pandas import DataFrame<br>from pandas_datareader import data<br>import pandas_datareader as pdr</p>
<p>%matplotlib inline<br>import matplotlib.pyplot as plt<br>import matplotlib as mpl</p>
<p>mpl.rcParams[‘font.sans-serif’] = [‘SimHei’]<br>mpl.rcParams[‘font.serif’] = [‘SimHei’]<br>import seaborn as sns<br>sns.set_style(“darkgrid”,{“font.sans-serif”:[‘simhei’, ‘Arial’]})</p>
<p>train_num = 50</p>
<p>#加载数据<br>def loadDataSet(fileName): #general function to parse tab -delimited floats<br>    numFeat = len(open(fileName).readline().split(‘\t’)) - 2 #get number of fields<br>    dataArr = []<br>    lonArr = []<br>    latArr = []<br>    fr = open(fileName)<br>    for line in fr.readlines():<br>        lineArr =[]<br>        lineArr.append(1.0) # 增加这一列是为了进行线性回归，存放常量x0<br>        curLine = line.strip().split(‘\t’)<br>        for i in range(numFeat):<br>            lineArr.append(float(curLine[i]))<br>        dataArr.append(lineArr)<br>        lonArr.append(float(curLine[-2])) # 倒数第二项是lon经度<br>        latArr.append(float(curLine[-1])) # 最后一项是lat纬度<br>    return dataArr,lonArr, latArr</p>
<p># 计算误差<br>def absError(yArr,yHatArr): #yArr and yHatArr both need to be arrays<br>    return abs(yArr-yHatArr).sum() / len(yArr)</p>
<p># 加载数据，分隔为train和test<br>dataArr,lonArr,latArr= loadDataSet(‘typhoon.dat’)</p>
<p>#加载测试数据<br>def loadTestDataSet(fileName): #general function to parse tab -delimited floats<br>    numFeat = len(open(fileName).readline().split(‘\t’)) #get number of fields<br>    dataArr = []<br>    fr = open(fileName)<br>    for line in fr.readlines():<br>        lineArr =[]<br>        lineArr.append(1.0) # 增加这一列是为了进行线性回归，存放常量x0<br>        curLine = line.strip().split(‘\t’)<br>        for i in range(numFeat):<br>            lineArr.append(float(curLine[i]))<br>        dataArr.append(lineArr)<br>    return dataArr</p>
<p>trainX=dataArr[0:500]; lonTrainY=lonArr[0:500]; latTrainY=latArr[0:500]<br># testX=dataArr[300:]; lonTestY=lonArr[300:]; latTestY=latArr[300:]<br>testX=loadTestDataSet(‘typhoon200Test.dat’)</p>
<p># 构建模型<br>clf = linear_model.LinearRegression() # 线性回归<br>clf1 = linear_model.Ridge (alpha = 0.8) # 岭回归<br># clf2 = linear_model.ElasticNet(alpha = 1.0) # ElasticNet线性<br># clf3 = linear_model.Lasso()</p>
<p>clf.fit (trainX, lonTrainY) # 训练经度模型<br>lonyHat = clf.predict(testX) # 使用经度模型去预测经度<br>clf.fit (trainX, latTrainY) # 训练纬度模型<br>latyHat = clf.predict(testX) # 使用纬度模型去预测纬度<br># # 经度误差<br># absErrorLon = absError(lonTestY,lonyHat)<br># # 纬度误差<br># absErrorLat = absError(latTestY,latyHat)<br># absErrorLen = 110 <em> sqrt(absErrorLon\</em>*2 + absErrorLat**2)</p>
<p>clf1.fit (trainX, lonTrainY) # 训练经度模型<br>lonyHat1 = clf1.predict(testX) # 使用经度模型去预测经度<br>clf1.fit (trainX, latTrainY) # 训练纬度模型<br>latyHat1 = clf1.predict(testX) # 使用纬度模型去预测纬度</p>
<p># print(lonyHat1)<br># print(latyHat)</p>
<p>data = []</p>
<p>for i in range(0, 200):<br>    data1 = []<br>    data1.append(lonyHat1[i])<br>    data1.append(latyHat[i])<br>    data.append(data1)</p>
<p>df = DataFrame(data)<br>df.to_csv(‘typhoon200Results.dat’, sep=’\t’, header=False, index=False)</p>
<p># # 经度误差<br># absErrorLon1 = absError(lonTestY,lonyHat1)<br># # 纬度误差<br># absErrorLat1 = absError(latTestY,latyHat1)<br># absErrorLen1 = 110 <em> sqrt(absErrorLon1\</em>*2 + absErrorLat1**2)</p>
<p># absErrorLen3333 = 110 <em> sqrt(absErrorLon1\</em>*2 + absErrorLat**2)</p>
<p># print( absErrorLen, absErrorLen1, absErrorLen3333)</p>
<h2 id="分析过程代码"><a href="#分析过程代码" class="headerlink" title="分析过程代码"></a>分析过程代码</h2><p>from __future__ import division<br>import os, sys<br>import numpy as np<br># from numpy import <em><br>from sklearn import linear_model<br>from math import </em></p>
<p>import pandas as pd<br>from pandas import DataFrame<br>from pandas_datareader import data<br>import pandas_datareader as pdr</p>
<p>%matplotlib inline<br>import matplotlib.pyplot as plt<br>import matplotlib as mpl</p>
<p>mpl.rcParams[‘font.sans-serif’] = [‘SimHei’]<br>mpl.rcParams[‘font.serif’] = [‘SimHei’]<br>import seaborn as sns<br>sns.set_style(“darkgrid”,{“font.sans-serif”:[‘simhei’, ‘Arial’]})</p>
<p>train_num = 50</p>
<p>#加载数据<br>def loadDataSet(fileName): #general function to parse tab -delimited floats<br>    numFeat = len(open(fileName).readline().split(‘\t’)) - 2 #get number of fields<br>    dataArr = []<br>    lonArr = []<br>    latArr = []<br>    fr = open(fileName)<br>    for line in fr.readlines():<br>        lineArr =[]<br>        lineArr.append(1.0) # 增加这一列是为了进行线性回归，存放常量x0<br>        curLine = line.strip().split(‘\t’)<br>        for i in range(numFeat):<br>            lineArr.append(float(curLine[i]))<br>        dataArr.append(lineArr)<br>        lonArr.append(float(curLine[-2])) # 倒数第二项是lon经度<br>        latArr.append(float(curLine[-1])) # 最后一项是lat纬度<br>    return dataArr,lonArr, latArr</p>
<p># 计算误差<br>def absError(yArr,yHatArr): #yArr and yHatArr both need to be arrays<br>    return abs(yArr-yHatArr).sum() / len(yArr)</p>
<p># 加载数据，分隔为train和test<br>dataArr,lonArr,latArr= loadDataSet(‘typhoon.dat’)</p>
<p>data_all = {‘data size’:[], ‘线性回归’:[], ‘岭回归’:[], ‘ElasticNet回归’:[], ‘Lasso回归’:[]}<br>data_LonLat_Err = {‘data size’:[], ‘线性回归Lon’:[], ‘岭回归Lon’:[], ‘ElasticNet回归Lon’:[],<br>                   ‘Lasso回归Lon’:[],<br>                  ‘线性回归Lat’:[], ‘岭回归Lat’:[], ‘ElasticNet回归Lat’:[],’Lasso回归Lat’:[]}<br>data_LonLat_corr = {‘data size’:[], ‘线性回归Lon’:[], ‘岭回归Lon’:[], ‘ElasticNet回归Lon’:[],<br>                   ‘Lasso回归Lon’:[],<br>                  ‘线性回归Lat’:[], ‘岭回归Lat’:[], ‘ElasticNet回归Lat’:[],’Lasso回归Lat’:[]}<br>for train_num in range(50, 300, 1):<br>    trainX=dataArr[0:train_num]; lonTrainY=lonArr[0:train_num]; latTrainY=latArr[0:train_num]<br>    testX=dataArr[300:]; lonTestY=lonArr[300:]; latTestY=latArr[300:]</p>
<pre><code>data\_all\[&apos;data size&apos;\].append(train\_num)
data\_LonLat\_Err\[&apos;data size&apos;\].append(train_num)
data\_LonLat\_corr\[&apos;data size&apos;\].append(train_num)

# 构建模型
clf = linear_model.LinearRegression() # 线性回归
clf1 = linear_model.Ridge (alpha = 0.8) # 岭回归
clf2 = linear_model.ElasticNet(alpha = 1.0) # ElasticNet线性
clf3 = linear_model.Lasso()


clf.fit (trainX, lonTrainY) # 训练经度模型
lonyHat = clf.predict(testX) # 使用经度模型去预测经度
clf.fit (trainX, latTrainY) # 训练纬度模型
latyHat = clf.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon = absError(lonTestY,lonyHat)
# 纬度误差
absErrorLat = absError(latTestY,latyHat)
absErrorLen = 110 * sqrt(absErrorLon\*\*2 + absErrorLat\*\*2)

data_all\[&apos;线性回归&apos;\].append(absErrorLen)

clf1.fit (trainX, lonTrainY) # 训练经度模型
lonyHat1 = clf1.predict(testX) # 使用经度模型去预测经度
clf1.fit (trainX, latTrainY) # 训练纬度模型
latyHat1 = clf1.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon1 = absError(lonTestY,lonyHat1)
# 纬度误差
absErrorLat1 = absError(latTestY,latyHat1)
absErrorLen1 = 110 * sqrt(absErrorLon1\*\*2 + absErrorLat1\*\*2)

data_all\[&apos;岭回归&apos;\].append(absErrorLen1)


clf2.fit (trainX, lonTrainY) # 训练经度模型
lonyHat2 = clf2.predict(testX) # 使用经度模型去预测经度
clf2.fit (trainX, latTrainY) # 训练纬度模型
latyHat2 = clf2.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon2 = absError(lonTestY,lonyHat2)
# 纬度误差
absErrorLat2 = absError(latTestY,latyHat2)
absErrorLen2 = 110 * sqrt(absErrorLon2\*\*2 + absErrorLat2\*\*2)

data_all\[&apos;ElasticNet回归&apos;\].append(absErrorLen2)


clf3.fit (trainX, lonTrainY) # 训练经度模型
lonyHat3= clf3.predict(testX) # 使用经度模型去预测经度
clf3.fit (trainX, latTrainY) # 训练纬度模型
latyHat3 = clf3.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon3 = absError(lonTestY,lonyHat3)
# 纬度误差
absErrorLat3 = absError(latTestY,latyHat3)
absErrorLen3 = 110 * sqrt(absErrorLon3\*\*2 + absErrorLat3\*\*2)

data_all\[&apos;Lasso回归&apos;\].append(absErrorLen3)

data\_LonLat\_Err\[&apos;线性回归Lon&apos;\].append(absErrorLon)
data\_LonLat\_Err\[&apos;岭回归Lon&apos;\].append(absErrorLon1)
data\_LonLat\_Err\[&apos;ElasticNet回归Lon&apos;\].append(absErrorLon2)
data\_LonLat\_Err\[&apos;Lasso回归Lon&apos;\].append(absErrorLon3)

data\_LonLat\_Err\[&apos;线性回归Lat&apos;\].append(absErrorLat)
data\_LonLat\_Err\[&apos;岭回归Lat&apos;\].append(absErrorLat1)
data\_LonLat\_Err\[&apos;ElasticNet回归Lat&apos;\].append(absErrorLat2)
data\_LonLat\_Err\[&apos;Lasso回归Lat&apos;\].append(absErrorLat3)

data\_LonLat\_corr\[&apos;线性回归Lon&apos;\].append(np.corrcoef(lonyHat, lonArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;岭回归Lon&apos;\].append(np.corrcoef(lonyHat1, lonArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;ElasticNet回归Lon&apos;\].append(np.corrcoef(lonyHat2, lonArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;Lasso回归Lon&apos;\].append(np.corrcoef(lonyHat3, lonArr\[300:\])\[0\]\[1\])

data\_LonLat\_corr\[&apos;线性回归Lat&apos;\].append(np.corrcoef(latyHat, latArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;岭回归Lat&apos;\].append(np.corrcoef(latyHat1, latArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;ElasticNet回归Lat&apos;\].append(np.corrcoef(latyHat2, latArr\[300:\])\[0\]\[1\])
data\_LonLat\_corr\[&apos;Lasso回归Lat&apos;\].append(np.corrcoef(latyHat3, latArr\[300:\])\[0\]\[1\])



#计算距离公式： 110*sqrt(lon^2+lat^2)
</code></pre><p>#     print(absErrorLen,absErrorLen1,absErrorLen2 )</p>
<pre><code># 计算经度预测值与真实值的相关系数
# print(np.corrcoef(lonyHat, lonArr\[400:\])\[0\]\[1\])
# 计算纬度预测值与真实值的相关系数
# print(np.corrcoef(latyHat, latArr\[400:\])\[0\]\[1\])
</code></pre><p># print(data_all)<br>data_all = DataFrame(data_all)<br>data_all.set_index([‘data size’], inplace=True)<br>data_all.plot(kind=’line’, figsize=(12,8),<br>             title=’训练样本量对预测距离误差的影响’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>data_LonLat_Err = DataFrame(data_LonLat_Err)<br>data_LonLat_Err.set_index([‘data size’], inplace=True)<br>data_LonLat_Err.plot(kind=’line’, figsize=(12,8),<br>             title=’训练样本量对预测经纬度误差的影响’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>data_LonLat_corr = DataFrame(data_LonLat_corr)<br>data_LonLat_corr.set_index([‘data size’], inplace=True)<br>data_LonLat_corr.plot(kind=’line’, figsize=(12,8),<br>             title=’训练样本量对预测经纬度与真实经纬度之间相关系数的影响’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>data_all = {‘data size’:[], ‘线性回归’:[], ‘岭回归’:[], ‘ElasticNet回归’:[], ‘Lasso回归’:[], ‘线性-岭回归’:[]}<br>for train_num in range(50, 300, 1):<br>    trainX=dataArr[0:train_num]; lonTrainY=lonArr[0:train_num]; latTrainY=latArr[0:train_num]<br>    testX=dataArr[300:]; lonTestY=lonArr[300:]; latTestY=latArr[300:]</p>
<pre><code>data\_all\[&apos;data size&apos;\].append(train\_num)
</code></pre><p>#     data_LonLat_Err[‘data size’].append(train_num)<br>#     data_LonLat_corr[‘data size’].append(train_num)</p>
<pre><code># 构建模型
clf = linear_model.LinearRegression() # 线性回归
clf1 = linear_model.Ridge (alpha = 0.8) # 岭回归
clf2 = linear_model.ElasticNet(alpha = 1.0) # ElasticNet线性
clf3 = linear_model.Lasso()


clf.fit (trainX, lonTrainY) # 训练经度模型
lonyHat = clf.predict(testX) # 使用经度模型去预测经度
clf.fit (trainX, latTrainY) # 训练纬度模型
latyHat = clf.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon = absError(lonTestY,lonyHat)
# 纬度误差
absErrorLat = absError(latTestY,latyHat)
absErrorLen = 110 * sqrt(absErrorLon\*\*2 + absErrorLat\*\*2)

data_all\[&apos;线性回归&apos;\].append(absErrorLen)

clf1.fit (trainX, lonTrainY) # 训练经度模型
lonyHat1 = clf1.predict(testX) # 使用经度模型去预测经度
clf1.fit (trainX, latTrainY) # 训练纬度模型
latyHat1 = clf1.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon1 = absError(lonTestY,lonyHat1)
# 纬度误差
absErrorLat1 = absError(latTestY,latyHat1)
absErrorLen1 = 110 * sqrt(absErrorLon1\*\*2 + absErrorLat1\*\*2)

data_all\[&apos;岭回归&apos;\].append(absErrorLen1)



clf2.fit (trainX, lonTrainY) # 训练经度模型
lonyHat2 = clf2.predict(testX) # 使用经度模型去预测经度
clf2.fit (trainX, latTrainY) # 训练纬度模型
latyHat2 = clf2.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon2 = absError(lonTestY,lonyHat2)
# 纬度误差
absErrorLat2 = absError(latTestY,latyHat2)
absErrorLen2 = 110 * sqrt(absErrorLon2\*\*2 + absErrorLat2\*\*2)

data_all\[&apos;ElasticNet回归&apos;\].append(absErrorLen2)


clf3.fit (trainX, lonTrainY) # 训练经度模型
lonyHat3= clf3.predict(testX) # 使用经度模型去预测经度
clf3.fit (trainX, latTrainY) # 训练纬度模型
latyHat3 = clf3.predict(testX) # 使用纬度模型去预测纬度
# 经度误差
absErrorLon3 = absError(lonTestY,lonyHat3)
# 纬度误差
absErrorLat3 = absError(latTestY,latyHat3)
absErrorLen3 = 110 * sqrt(absErrorLon3\*\*2 + absErrorLat3\*\*2)

data_all\[&apos;Lasso回归&apos;\].append(absErrorLen3)


absErrorLen333 = 110 * sqrt(absErrorLon1\*\*2 + absErrorLat\*\*2)

data_all\[&apos;线性-岭回归&apos;\].append(absErrorLen333)
</code></pre><p>data_all = DataFrame(data_all)<br>data_all.set_index([‘data size’], inplace=True)<br>data_all.plot(kind=’line’, figsize=(12,8),<br>             title=’训练样本量对预测距离误差的影响’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/sklearn-predict-typhoon/" data-id="cjqn5ydn3000l0wuuwinimtgd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataAnalysis/">DataAnalysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-virtual-currency-automatic-trading-data" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/16/virtual-currency-automatic-trading-data/" class="article-date">
  <time datetime="2018-04-16T14:41:36.000Z" itemprop="datePublished">2018-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Blockchains/">Blockchains</a>►<a class="article-category-link" href="/categories/Blockchains/Digital-currency/">Digital currency</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/16/virtual-currency-automatic-trading-data/">关于通过脚本实现虚拟货币量化交易的部分交易数据（17w+条）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  通过脚本在币安网(binance.com)实现的虚拟货币自动交易的交易数据（量化交易）   通过程序进行的量化交易，一个月盈利500%左右 包含我本人大约一个月的交易数据，总共17w+条   （期间因改进代码、币安停服升级等原因中断过数天）   详见<a href="https://github.com/Gaobx/virtual-currency-automatic-trading-data" target="_blank" rel="noopener">https://github.com/Gaobx/virtual-currency-automatic-trading-data</a>   如有使用价值，请告知<a href="mailto:i@gaojx.cn" target="_blank" rel="noopener">i@gaojx.cn</a> 后使用     <img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1523899947364&amp;di=9548d02792d267de6626611e8cbe42d1&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.hibor.com.cn%2FsinaImg%2F201803%2FLUWi-fysnevk6861145.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/16/virtual-currency-automatic-trading-data/" data-id="cjqn5ydn6000n0wuu032k4owl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Digital-currency/">Digital currency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchains/">blockchains</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-python-week-number" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/16/mysql-python-week-number/" class="article-date">
  <time datetime="2018-04-15T16:45:10.000Z" itemprop="datePublished">2018-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/未分类/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/16/mysql-python-week-number/">关于mysql和python跨年周以及当前周的计算问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  在写某个后端时，需要使用python的pymysql从数据库获取<strong>上周</strong>的数据 然而数据总是不对，bug找了两三个小时才找出来，下面是bug出现的原因，以及关于mysql和python周数的计算方法的总结。</p>
<hr>
<p>  python代码中sql语句的where部分：</p>
<p>“WHERE YEARWEEK(date_format(commit_time,’%%Y-%%m-%%d’)) = YEARWEEK(now())- 1”</p>
<p>语句意思是，把当前时间转换为周数，再把数据库中相应datetime字段也转换为周数，两者之间相差1即可。   当前日期是2018/4/15星期日。 在python中通过datetime.datetime.now().isocalendar()[1] 可以得到当前周数是15； 通过上述sql语句select出上周数据后，在python中选出了mysql返回的数据中时间最靠后的一条数据，对该数据的时间项利用isocalendar()求周数。 然而上述python程序返回的结果也是15（本应该是上周的周数14）。   所以就考虑到很可能是python和mysql计算周数的方式不同，而今天恰巧是周日，有可能是SQL将今天算作了新的一周，即第16周，所以返回的上周数据在python中计算的周数为15。 在mysql中运行语句SELECT  YEARWEEK(now()); 结果j截图如下 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/mysql-python-week-nm/yearweek.png" alt=""> 即显示的是当前时间为2018年第15周。 如果按照周日算作新的一周，当前应该是第16周才对。   进一步查阅网上的万年历 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/mysql-python-week-nm/wannianli.png" alt=""> 也显示今天为第十五周。 很让人费解。   那么下面通过查看sql语句查询结果的数据情况发现，数据中最靠后的日期的2018-4-14 23:17:32, 即为前一天。 在mysql中执行SELECT  YEARWEEK(‘2018-4-14 23:17:32’); 结果是201814, 即第14周。   后来经过不断尝试发现，<strong>mysql不仅把周日当做了新的一周，而且是把每年的第一个周日后的那一周当做第一周</strong>。 举个例子 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/mysql-python-week-nm/wannianli2.png" alt=""> <strong>这是2018年1月的日历，在mysql中，1月7号到1月13号才算做是2018年第1周，1月1号到1月6号还算作是2017年的第53周。</strong> <strong>而在python中，1月1号到1月7号算作是第1周。</strong>   所以在python代码中执行上述语句返回结果是4月8号（星期日）到4月14号（星期六）的数据，而python取了最后一条数据来计算周数，即计算4月14号的周数。 所以会导致在上述bug的产生。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/16/mysql-python-week-number/" data-id="cjqn5ydmz000g0wuuuilwounp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-analyze-stock" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/analyze-stock/" class="article-date">
  <time datetime="2018-04-15T08:41:28.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataAnalysis/">DataAnalysis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/analyze-stock/">使用pandas和matplotlib分析各类股票数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  本篇内容：网络数据采集美交所、沪深交所的多种不同题材股票交易信息，使用python的pandas和matplotlib分析趋势、相关性、可视化等。</p>
<hr>
<p>  <em>以下均在ipython notebook中进行分析。</em>   从Yahoo! Finance下载美交所特斯拉、58同城、网易、百度以及亚马逊的股票数据； 下载豫能控股、申能股份、东材科技、盾安环境以及博威合金等沪深交所新能源类股票； 下载中国太保、中国人寿、天茂集团、中国平安以及新华保险等沪深交所保险类股票； 下载游族网络、浪潮软件、皖通科技、北纬科技以及浙大网新等沪深交所互联网类股票。  </p>
<p>import pandas as pd<br>from pandas import DataFrame<br>import numpy as np<br>from pandas_datareader import data<br>import pandas_datareader as pdr</p>
<p>%matplotlib inline<br>import matplotlib.pyplot as plt<br>import matplotlib as mpl</p>
<p>mpl.rcParams[‘font.sans-serif’] = [‘SimHei’]<br>mpl.rcParams[‘font.serif’] = [‘SimHei’]<br>import seaborn as sns<br>sns.set_style(“darkgrid”,{“font.sans-serif”:[‘simhei’, ‘Arial’]})</p>
<p>stocks = [‘TSLA’, ‘WUBA’, ‘NTES’, ‘BIDU’, ‘AMZN’,<br>          ‘001896.SZ’, ‘600642.SS’, ‘601208.SS’, ‘002011.SZ’, ‘601137.SS’,<br>          ‘601601.SS’, ‘601628.SS’, ‘000627.SZ’, ‘601318.SS’, ‘601336.SS’,<br>          ‘002174.SZ’, ‘600756.SS’, ‘002331.SZ’, ‘002148.SZ’, ‘600797.SS’,]<br>names = [ ‘特斯拉’, ‘58同城’, ‘网易’, ‘百度’, ‘亚马逊’,<br>         ‘豫能控股’, ‘申能股份’, ‘东材科技’, ‘盾安环境’, ‘博威合金’,<br>         ‘中国太保’, ‘中国人寿’, ‘天茂集团’, ‘中国平安’, ‘新华保险’,<br>         ‘游族网络’, ‘浪潮软件’, ‘皖通科技’, ‘北纬科技’, ‘浙大网新’]<br>for i in range(len(stocks)):<br>    name = pdr.get_data_yahoo(stocks[i])<br>    path = ‘data/‘ + names[i] + ‘.csv’<br>    out_file = open(path, ‘w’)<br>    name.to_csv(out_file)<br>    out_file.close()</p>
<p>  下面是对股票数据进行整理，并且绘制图表的过程： 对原始数据按各项指标（开盘价、收盘价、最高价以及最低价等）进行分类，并且有必要对数据进行归一化处理，消除价格因素对股票趋势判断的影响；并对股票进行趋势分析、相关性分析等。  </p>
<h3 id="要点说明"><a href="#要点说明" class="headerlink" title="要点说明"></a>要点说明</h3><ul>
<li>在选取股票时，为了方便分析，尽量选取记录超过1000个交易日的股票，并且取今天以前1000个交易日的数据进行分析</li>
<li>在对多支股票的趋势进行分析时，股票价格会影响趋势的判断，需要对股价进行归一化处理。<ul>
<li>常见的归一化方法（<a href="https://blog.csdn.net/hjxzb/article/details/78610961" target="_blank" rel="noopener">链接</a>）：<ul>
<li>min-max标准化</li>
<li>Z-score标准化方法</li>
</ul>
</li>
<li>这里采用min-max标准化方法</li>
</ul>
</li>
<li>采用pearson相关系数进行相关性分析</li>
</ul>
<h3 id="股价总览"><a href="#股价总览" class="headerlink" title="股价总览"></a>股价总览</h3><p>data_set = {}<br>data_set[‘美股科技类’] = [ names[i] for i in range(0, 5)]<br>data_set[‘新能源类’] = [ names[i] for i in range(5, 10)]<br>data_set[‘保险类’] = [ names[i] for i in range(10, 15)]<br>data_set[‘互联网类’] = [ names[i] for i in range(15, 20)]</p>
<p>data_all = {}<br>for i in names:<br>    file_name = ‘data/‘ + i + ‘.csv’<br>    f = open(file_name)<br>    data = pd.read_csv(f)<br>    data = data.head(1000)<br>#     print(i, data[‘close’].median())<br>    data_all[i] = data[‘adjclose’]<br>data_all[‘date’] = data[‘date’]<br>data_all = DataFrame(data_all)<br>data_all.set_index([‘date’], inplace=True)<br>data_all.index = pd.to_datetime(data_all.index)</p>
<p>data_all.plot(kind=’line’, figsize=(12,8),<br>             title=’所有股票原始数据（1000个交易日）’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p># data_all.corr()</p>
<p>df = data_all<br>for i in data_all.columns:<br>    df[i] = df[i].rolling(window=42, center=False).mean()</p>
<p>df.plot(kind=’line’, figsize=(12,8),<br>             title=’所有股票移动平均值42d（1000个交易日）’)<br>plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p># data_all.corr()</p>
<p>  <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/all_1.png" alt=""> 此图表显示了所有股票在过去1000个交易日内的收盘价格 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/all_2.png" alt=""> 此图表显示了所有股票在过去1000个交易日中42d移动平均值 由此可见，除个别股票趋势明显外，大多数股票趋势难以判断，需要分类别进行后续分析。  </p>
<h3 id="美股科技类"><a href="#美股科技类" class="headerlink" title="美股科技类"></a>美股科技类</h3><p>data_all_1 = {}<br>for i in data_set[‘美股科技类’]:<br>    file_name = ‘data/‘ + i + ‘.csv’<br>    f = open(file_name)<br>    data = pd.read_csv(f)<br>    data = data.head(1000)<br>    data_all_1[i] = data[‘adjclose’]<br>#     data_all_1[i] = (data[‘adjclose’] - data[‘adjclose’].min())/(data[‘adjclose’].max() - data[‘adjclose’].min())<br>data_all_1[‘date’] = data[‘date’]<br>data_all_1 = DataFrame(data_all_1)<br>data_all_1.set_index([‘date’], inplace=True)<br>data_all_1.index = pd.to_datetime(data_all_1.index)<br>data_all_1.plot(kind=’line’, figsize=(10,6), title=’美股科技类股票原始数据（1000个交易日）’)<br># plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>df = data_all_1<br>for i in data_all_1.columns:<br>    df[i] = df[i].rolling(window=42, center=False).mean()</p>
<p>df.plot(kind=’line’, figsize=(10,6),<br>             title=’美股科技类移动平均值42d（1000个交易日）’)<br># plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>data_all_1 = {}<br>for i in data_set[‘美股科技类’]:<br>    file_name = ‘data/‘ + i + ‘.csv’<br>    f = open(file_name)<br>    data = pd.read_csv(f)<br>    data = data.head(1000)<br>    data_all_1[i] = data[‘adjclose’]<br>    data_all_1[i] = (data[‘adjclose’] - data[‘adjclose’].min())/(data[‘adjclose’].max() - data[‘adjclose’].min())<br>data_all_1[‘date’] = data[‘date’]<br>data_all_1 = DataFrame(data_all_1)<br>data_all_1.set_index([‘date’], inplace=True)<br>data_all_1.index = pd.to_datetime(data_all_1.index)<br>data_all_1.plot(kind=’line’, figsize=(10,6), title=’美股科技类股票数据（1000个交易日）’)<br># plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>df = data_all_1<br>for i in data_all_1.columns:<br>    df[i] = df[i].rolling(window=42, center=False).mean()</p>
<p>df.plot(kind=’line’, figsize=(10,6),<br>             title=’经归一化处理的美股科技类移动平均值42d（1000个交易日）’)<br># plt.legend(bbox_to_anchor=(1.0, 1))</p>
<p>data_all_1.corr()</p>
<p>  <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/meigu_1.png" alt=""> 此图表显示了科技类美股在过去1000个交易日内的收盘价格   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/meigu_2.png" alt=""> 此图显示了科技类美股在过去1000个交易日内42d移动平均值 通过该图表可以看到，亚马逊股票在此期间上升趋势明显，并且价格明显高于其他股票。 为了消除价格因素对股票趋势分析的影响，需要对股票数据采用归一化处理。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/meigu_3.png" alt="">   此图表显示了经归一化处理后的科技类美股1000个交易日内42d移动平均值 通过此图表可以看出亚马逊和网易股价呈明显上升趋势；特斯拉股价在2016年末以前在特定区间内呈震荡走势，过后呈明显上升趋势；58同城和百度股价处于波动状态。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/meigu_4.png" alt=""> 此表显示了科技类美股Pearson相关系数矩阵 从表中可以看出亚马逊和网易股价相关系数为0.95，相关性很强；其次特斯拉与网易之间、特斯拉与亚马逊之间相关系数皆约为0.7，相关性较强；并且所有股票价格均呈正相关。  </p>
<h3 id="沪深交所新能源类"><a href="#沪深交所新能源类" class="headerlink" title="沪深交所新能源类"></a>沪深交所新能源类</h3><p>代码略。 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/xinnegyuan_1.png" alt=""> 此图表显示了科技类美股在过去1000个交易日内的收盘价格 可以看出，所选新能源类股票走势基本相同，可以通过42d移动平均值来进一步验证结论。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/xinnegyuan_3.png" alt=""> 此图显示了沪深交所新能源类股票在过去1000个交易日内42d移动平均值 通过该图表可以看到，所有新能源类股票在2015年有较大幅度的上涨，并且在下半年股价有所回调；2016年至今，所有新能源类股票都呈震荡趋势。 为了消除价格因素对股票趋势分析的影响，下面对股票数据采用归一化处理。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/xinnengyuan_2.png" alt=""> 此图表显示了经归一化处理后的沪深交所新能源类股票1000个交易日内42d移动平均值 通过此图表可以看出所有股票在2015年四月之前呈上涨趋势，并且在2015年下半年有较大幅度的回调；其中博威合金在回调后走出了第二轮上涨趋势，其余股票在波动后都有所回落。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/xinnengyuan_4.png" alt=""> 此表显示了沪深交所新能源类股票Pearson相关系数矩阵 从表中可以看出东财科技与除博威合金之外的其他所有股票相关性都比较强，豫能控股、申能股份、盾安环境也是如此；博威合金与其他所有股票相关性都比较弱。  </p>
<h3 id="沪深交所保险类"><a href="#沪深交所保险类" class="headerlink" title="沪深交所保险类"></a>沪深交所保险类</h3><p>代码略。 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/baoxian_1.png" alt=""> 此图表显示了沪深交所保险类股票在过去1000个交易日内的收盘价格 由图可见，各个股票走势大致相同，可以通过下面的42d移动平均值进行验证。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/baoxian_2.png" alt=""> 此图显示了沪深交所保险类股票在过去1000个交易日内42d移动平均值 通过该图表可以看到，所有股票在2015年和2018年都有个阶段性上涨阶段，随后回落；总体趋势是类似的，股价在震荡上涨。 为了消除价格因素对股票趋势分析的影响，需要对股票数据采用归一化处理。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/baoxian_3.png" alt=""> 此图表显示了经归一化处理后的沪深交所保险类股票1000个交易日内42d移动平均值 通过此图表可以看出所有股票在2015年与2018年出现了大幅上涨的趋势，并且在过后都有所回落，与之前讨论结果相同。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/baoxian_4.png" alt=""> 此表显示了科技类美股Pearson相关系数矩阵 从表中可以看出大部分保险类股票之间是强相关的；相关性最弱的天茂集团与中国平安之间的相关系数也为0.53，说明该行业之间股票的走势是联动的，相关性很强。  </p>
<h3 id="沪深交所互联网类"><a href="#沪深交所互联网类" class="headerlink" title="沪深交所互联网类"></a>沪深交所互联网类</h3><p>代码略。 <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/hulianwang_1.png" alt=""> 此图显示了沪深交所互联网类股票在过去1000个交易日内的收盘价格   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/hulianwang_2.png" alt=""> 此图显示了沪深交所互联网类股票在过去1000个交易日内42d移动平均值 通过该图表可以看到，皖通科技、浪潮软件和游族网络股价波动较大；北纬科技和浙大网新股价波动相对较小；总体呈区间内震荡趋势。 为了消除价格因素对股票趋势分析的影响，需要对股票数据采用归一化处理。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/hulianwang_3.png" alt=""> 此图表显示了经归一化处理后的沪深交所互联网类股票1000个交易日内42d移动平均值 通过此图表可以看出所有股票皆为波动趋势；2015年上半年除浪潮软件外所有股票大幅上涨，随后回落，浪潮软件上涨较为滞后。   <img src="http://gaojx-1253732420.file.myqcloud.com/%E7%B4%A0%E6%9D%90/analyze-stocks/hulianwang_4.png" alt=""> 此表显示了科技类美股Pearson相关系数矩阵 从表中可以看出游族网络、浙大网新以及皖通科技三者之间相关性较强；其他股票相关性较弱，且北纬科技与浪潮软件之间呈现较弱的负相关状态。  </p>
<ul>
<li>沪深交所绝大部分股票在2015年出现了大幅度的上涨趋势，随后有较大的回落。美交所股票并无明显的此种现象。</li>
<li>沪深交所同题材下的股票价格走势有比较强的相关性。由此猜测，国内一些政策性的利好、利空消息会对股票价格产生较大的影响。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/analyze-stock/" data-id="cjqn5ydmk00020wuucxiiby60" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataAnalysis/">DataAnalysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-install-anaconda" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/27/install-anaconda/" class="article-date">
  <time datetime="2018-03-27T12:43:54.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Capriccio/">Capriccio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/27/install-anaconda/">在服务器上装Anaconda给自己挖的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务器用的是centOS系统，装Anaconda的步骤如下 第一步，下载Anaconda 如果直接在官网下会很慢，可以用清华镜像下载。<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华镜像</a> 如，我下载的是Anaconda3-5.1.0，64位linux版：</p>
<p>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.1.0-Linux-x86_64.sh" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.1.0-Linux-x86_64.sh</a></p>
<p>  第二步，安装</p>
<p>bash Anaconda3-5.1.0-Linux-x86_64.sh</p>
<p>在安装过程中会有个Cryptography Notice，一直按回车才会继续。 在下面这个地方不要回车，静静等就行，不然到最后会直接跳过添加环境变量的环节 <img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/ana1.jpg" alt=""> 安装到最后有一个Do you wish the installer to prepend the Anaconda3 install location to PATH in your /root/.bashrc ? [yes|no] <img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/anaconda.PNG" alt="">   关于设置Anaconda环境变量，这里填yes。 如果没及时填yes，会默认no，只能后面手动添加环境变量。 在我安装的时候，由于多按了一次回车，导致没有添加到环境变量。 手动添加环境变量后也还是不能用，因为也不是很着急用，陆陆续续一星期最后发现，   tm添加环境变量后忘记重启了！！！   最近在三台服务器上配置anaconda，每次都出了这个错误，orz…………………….. 写一下算是警醒自己吧…..</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/27/install-anaconda/" data-id="cjqn5ydmt00070wuuemr0phlz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learn-blockchains-by-building-one" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/learn-blockchains-by-building-one/" class="article-date">
  <time datetime="2018-02-06T15:41:18.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Blockchains/">Blockchains</a>►<a class="article-category-link" href="/categories/Blockchains/Digital-currency/">Digital currency</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/learn-blockchains-by-building-one/">Learn Blockchains by Building One</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>出处：<a href="https://pythoncaff.com/topics/82/build-your-own-block-chain-step-by-step-with-python" target="_blank" rel="noopener">https://pythoncaff.com/topics/82/build-your-own-block-chain-step-by-step-with-python</a></p>
<hr>
<p>你是否会和我一样，对加密数字货币底层的区块链技术非常感兴趣，特别想了解他们的运行机制。 但是学习区块链技术并非一帆风顺，我看多了大量的视频教程还有各种课程，最终的感觉就是真正可用的实战课程太少。 我喜欢在实践中学习，尤其喜欢以代码为基础去了解整个工作机制。如果你我一样喜欢这种学习方式，当你学完本教程时，你将会知道区块链技术是如何工作的。</p>
<h3 id="写在开始之前"><a href="#写在开始之前" class="headerlink" title="写在开始之前"></a>写在开始之前</h3><p>记住，区块链是一个 <em>不可变的、有序的</em> 被称为块的记录链。它们可以包含交易、文件或任何您喜欢的数据。但重要的是，他们用_哈希_ 一起被链接在一起。 如果你不熟悉哈希, <a href="https://learncryptography.com/hash-functions/what-are-hash-functions" target="_blank" rel="noopener">这里是一个解释</a>. <em>该指南的目的是什么?</em> 你可以舒服地阅读和编写基础的Python，因为我们将通过HTTP与区块链进行讨论，所以你也要了解HTTP的工作原理。 <em>我需要准备什么?</em> 确定安装了 <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 3.6</a>+ (还有 <code>pip</code>) ，你还需要安装 Flask、 Requests 库:</p>
<p>pip install Flask==0.12.2 requests==2.18.4</p>
<p>对了, 你还需要一个支持HTTP的客户端, 比如 <a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a> 或者 cURL，其他也可以。 <a href="https://github.com/dvf/blockchain" target="_blank" rel="noopener">源码 可以点击这里</a></p>
<hr>
<h3 id="Step-1-创建一个区块链"><a href="#Step-1-创建一个区块链" class="headerlink" title="Step 1: 创建一个区块链"></a>Step 1: 创建一个区块链</h3><p>打开你最喜欢的文本编辑器或者IDE, 我个人比较喜欢 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a>. 新建一个名为<code>blockchain.py</code>的文件。 我们将只用这一个文件就可以。但是如果你还是不太清楚, 你也可以参考 <a href="https://github.com/dvf/blockchain" target="_blank" rel="noopener">源码</a>.</p>
<h4 id="描述区块链"><a href="#描述区块链" class="headerlink" title="描述区块链"></a>描述区块链</h4><p>我们要创建一个 <code>Blockchain</code> 类 ，他的构造函数创建了一个初始化的空列表（要存储我们的区块链），并且另一个存储交易。下面是我们这个类的实例: <em>blockchain.py</em></p>
<p>class Blockchain(object):<br>    def __init__(self):<br>        self.chain = []<br>        self.current_transactions = []</p>
<pre><code>def new_block(self):
    # Creates a new Block and adds it to the chain
    pass

def new_transaction(self):
    # Adds a new transaction to the list of transactions
    pass

@staticmethod
def hash(block):
    # Hashes a Block
    pass

@property
def last_block(self):
    # Returns the last Block in the chain
    pass
</code></pre><p>我们的 <code>Blockchain</code> 类负责管理链式数据，它会存储交易并且还有添加新的区块到链式数据的Method。让我们开始扩充更多Method</p>
<hr>
<h4 id="块是什么样的"><a href="#块是什么样的" class="headerlink" title="块是什么样的 ?"></a>块是什么样的 ?</h4><p>每个块都有一个 <code>索引</code>，一个 <code>时间戳（Unix时间戳）</code>，一个<code>事务列表</code>， 一个 <code>校验</code>(稍后详述) 和 <code>前一个块的散列</code> 。 下面是一个Block的例子 ： <em>blockchain.py</em></p>
<p>block = {<br>    ‘index’: 1,<br>    ‘timestamp’: 1506057125.900785,<br>    ‘transactions’: [<br>        {<br>            ‘sender’: “8527147fe1f5426f9dd545de4b27ee00”,<br>            ‘recipient’: “a77f5cdfa2934df3954a5c7c7da5df1f”,<br>            ‘amount’: 5,<br>        }<br>    ],<br>    ‘proof’: 324984774000,<br>    ‘previous_hash’: “2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824”<br>}</p>
<p>在这一点上，一个 <code>区块链</code> 的概念应该是明显的 - 每个新块都包含在其内的前一个块的 <code>散列</code> 。 这是至关重要的，因为这是 <code>区块链</code> 不可改变的原因：如果攻击者损坏 <code>区块链</code> 中较早的块，则所有后续块将包含不正确的哈希值。 <em>这有道理吗？ 如果你还没有想通，花点时间仔细思考一下 - 这是区块链背后的核心理念</em></p>
<hr>
<h4 id="添加交易到区块"><a href="#添加交易到区块" class="headerlink" title="添加交易到区块"></a>添加交易到区块</h4><p>我们将需要一个添加交易到区块的方式。我们的 <code>new_transaction()</code>方法的责任就是这个， 并且它非常的简单: <em>blockchain.py</em></p>
<p>class Blockchain(object):<br>    …</p>
<pre><code>def new_transaction(self, sender, recipient, amount):
    &quot;&quot;&quot;
    Creates a new transaction to go into the next mined Block
    :param sender: &lt;str&gt; Address of the Sender
    :param recipient: &lt;str&gt; Address of the Recipient
    :param amount: &lt;int&gt; Amount
    :return: &lt;int&gt; The index of the Block that will hold this transaction
    &quot;&quot;&quot;

    self.current_transactions.append({
        &apos;sender&apos;: sender,
        &apos;recipient&apos;: recipient,
        &apos;amount&apos;: amount,
    })

    return self.last_block\[&apos;index&apos;\] + 1
</code></pre><p><code>new_transaction()</code> 方法添加了交易到列表，它返回了交易将被添加到的区块的_索引<em>---</em>讲开采下一个_这对稍后对提交交易的用户有用。</p>
<hr>
<h4 id="创建新的区块"><a href="#创建新的区块" class="headerlink" title="创建新的区块"></a>创建新的区块</h4><p>当我们的  <code>Blockchain</code>  被实例化后，我们需要将 _创世_ 区块（一个没有前导区块的区块）添加进去进去。我们还需要向我们的起源块添加一个 _证明_，这是挖矿的结果(或工作证明)。 我们稍后会详细讨论挖矿。 除了在构造函数中创建 _创世_ 区块外，我们还会补全  <code>new_block()</code> 、  <code>new_transaction()</code>  和 <code>hash()</code>函数： <em>blockchain.py</em></p>
<p>import hashlib<br>import json<br>from time import time</p>
<p>class Blockchain(object):<br>    def __init__(self):<br>        self.current_transactions = []<br>        self.chain = []</p>
<pre><code>    # 创建创世区块
    self.new\_block(previous\_hash=1, proof=100)

def new\_block(self, proof, previous\_hash=None):
    &quot;&quot;&quot;
    创建一个新的区块到区块链中
    :param proof: &lt;int&gt; 由工作证明算法生成的证明
    :param previous_hash: (Optional) &lt;str&gt; 前一个区块的 hash 值
    :return: &lt;dict&gt; 新区块
    &quot;&quot;&quot;

    block = {
        &apos;index&apos;: len(self.chain) + 1,
        &apos;timestamp&apos;: time(),
        &apos;transactions&apos;: self.current_transactions,
        &apos;proof&apos;: proof,
        &apos;previous\_hash&apos;: previous\_hash or self.hash(self.chain\[-1\]),
    }

    # 重置当前交易记录
    self.current_transactions = \[\]

    self.chain.append(block)
    return block

def new_transaction(self, sender, recipient, amount):
    &quot;&quot;&quot;
    创建一笔新的交易到下一个被挖掘的区块中
    :param sender: &lt;str&gt; 发送人的地址
    :param recipient: &lt;str&gt; 接收人的地址
    :param amount: &lt;int&gt; 金额
    :return: &lt;int&gt; 持有本次交易的区块索引
    &quot;&quot;&quot;
    self.current_transactions.append({
        &apos;sender&apos;: sender,
        &apos;recipient&apos;: recipient,
        &apos;amount&apos;: amount,
    })

    return self.last_block\[&apos;index&apos;\] + 1

@property
def last_block(self):
    return self.chain\[-1\]

@staticmethod
def hash(block):
    &quot;&quot;&quot;
    给一个区块生成 SHA-256 值
    :param block: &lt;dict&gt; Block
    :return: &lt;str&gt;
    &quot;&quot;&quot;

    # 我们必须确保这个字典（区块）是经过排序的，否则我们将会得到不一致的散列
    block\_string = json.dumps(block, sort\_keys=True).encode()
    return hashlib.sha256(block_string).hexdigest()
</code></pre><p>上面的代码应该是直白的 --- 为了让代码清晰，我添加了一些注释和文档说明。 我们差不多完成了我们的区块链。 但在这个时候你一定很疑惑新的块是怎么被创建、锻造或挖掘的。</p>
<hr>
<h4 id="工作量证明算法"><a href="#工作量证明算法" class="headerlink" title="工作量证明算法"></a>工作量证明算法</h4><p>使用工作量证明（PoW）算法，来证明是如何在区块链上创建或挖掘新的区块。PoW 的目标是计算出一个符合特定条件的数字，这个数字对于所有人而言必须在计算上非常困难，但易于验证。这是工作证明背后的核心思想。 我们将看到一个简单的例子帮助你理解： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设 x = 5，求 y ？用 Python 实现：</p>
<p>from hashlib import sha256<br>x = 5<br>y = 0  # We don’t know what y should be yet…<br>while sha256(f’{x*y}’.encode()).hexdigest()[-1] != “0”:<br>    y += 1<br>print(f’The solution is y = {y}’)</p>
<p>结果是： y = 21。因为，生成的 Hash 值结尾必须为 0。</p>
<p>hash(5 * 21) = 1253e9373e…5e3600155e860</p>
<p>在比特币中，工作量证明算法被称为 <a href="https://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">Hashcash</a> ，它和上面的问题很相似，只不过计算难度非常大。这就是矿工们为了争夺创建区块的权利而争相计算的问题。 通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，就会获得一定数量的比特币奖励（通过交易）。 验证结果，当然非常容易。</p>
<hr>
<p>实现工作量证明 让我们来实现一个相似 PoW 算法。规则类似上面的例子：</p>
<ul>
<li>[mark]找到一个数字 P ，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。[/mark]</li>
</ul>
<p><em>blockchain.py</em></p>
<p>import hashlib<br>import json</p>
<p>from time import time<br>from uuid import uuid4</p>
<p>class Blockchain(object):<br>    …</p>
<pre><code>def proof\_of\_work(self, last_proof):
    &quot;&quot;&quot;
    Simple Proof of Work Algorithm:
     \- Find a number p&apos; such that hash(pp&apos;) contains leading 4 zeroes, where p is the previous p&apos;
     \- p is the previous proof, and p&apos; is the new proof
    :param last_proof: &lt;int&gt;
    :return: &lt;int&gt;
    &quot;&quot;&quot;

    proof = 0
    while self.valid\_proof(last\_proof, proof) is False:
        proof += 1

    return proof

@staticmethod
def valid\_proof(last\_proof, proof):
    &quot;&quot;&quot;
    Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
    :param last_proof: &lt;int&gt; Previous Proof
    :param proof: &lt;int&gt; Current Proof
    :return: &lt;bool&gt; True if correct, False if not.
    &quot;&quot;&quot;

    guess = f&apos;{last_proof}{proof}&apos;.encode()
    guess_hash = hashlib.sha256(guess).hexdigest()
    return guess_hash\[:4\] == &quot;0000&quot;
</code></pre><p>衡量算法复杂度的办法是修改零开头的个数。使用 4 个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在 Blockchain 类基本已经完成了，接下来使用 HTTP requests 来进行交互。</p>
<hr>
<h3 id="Step-2-Blockchain-作为-API-接口"><a href="#Step-2-Blockchain-作为-API-接口" class="headerlink" title="Step 2: Blockchain 作为 API 接口"></a>Step 2: Blockchain 作为 API 接口</h3><p>我们将使用 Python Flask 框架，这是一个轻量 Web 应用框架，它方便将网络请求映射到 Python 函数，现在我们来让 Blockchain 运行在基于 Flask web 上。 我们将创建三个接口：</p>
<ul>
<li><code>/transactions/new</code> 创建一个交易并添加到区块</li>
<li><code>/mine</code> 告诉服务器去挖掘新的区块</li>
<li><code>/chain</code> 返回整个区块链</li>
</ul>
<h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>我们的“Flask 服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： <em>blockchain.py</em></p>
<p>import hashlib<br>import json<br>from textwrap import dedent<br>from time import time<br>from uuid import uuid4</p>
<p>from flask import Flask</p>
<p>class Blockchain(object):<br>    …</p>
<p># Instantiate our Node<br>app = Flask(__name__)</p>
<p># Generate a globally unique address for this node<br>node_identifier = str(uuid4()).replace(‘-‘, ‘’)</p>
<p># Instantiate the Blockchain<br>blockchain = Blockchain()</p>
<p>@app.route(‘/mine’, methods=[‘GET’])<br>def mine():<br>    return “We’ll mine a new Block”</p>
<p>@app.route(‘/transactions/new’, methods=[‘POST’])<br>def new_transaction():<br>    return “We’ll add a new transaction”</p>
<p>@app.route(‘/chain’, methods=[‘GET’])<br>def full_chain():<br>    response = {<br>        ‘chain’: blockchain.chain,<br>        ‘length’: len(blockchain.chain),<br>    }<br>    return jsonify(response), 200</p>
<p>if __name__ == ‘__main__‘:<br>    app.run(host=’0.0.0.0’, port=5000)</p>
<p>简单的说明一下以上代码：</p>
<ul>
<li>第 15 行：实例化节点。阅读更多关于 <a href="http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application" target="_blank" rel="noopener">Flask</a> 内容。</li>
<li>第 18 行：为节点创建一个随机的名称。.</li>
<li>第 21 行：实例化 Blockchain 类。</li>
<li>第 24–26 行：创建 /mine 接口，GET 方式请求。</li>
<li>第 28–30 行：创建 /transactions/new 接口，POST 方式请求，可以给接口发送交易数据。</li>
<li>第 32–38 行：创建 /chain 接口，返回整个区块链。</li>
<li>第 40–41 行：服务器运行端口 5000 。</li>
</ul>
<hr>
<h4 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h4><p>发送到节点的交易数据结构如下：</p>
<p>{<br> “sender”: “my address”,<br> “recipient”: “someone else’s address”,<br> “amount”: 5<br>}</p>
<p>因为我们已经有了添加交易的方法，所以基于接口来添加交易就很简单了。让我们为添加事务写函数: <em>blockchain.py</em></p>
<p>import hashlib<br>import json<br>from textwrap import dedent<br>from time import time<br>from uuid import uuid4</p>
<p>from flask import Flask, jsonify, request</p>
<p>…</p>
<p>@app.route(‘/transactions/new’, methods=[‘POST’])<br>def new_transaction():<br>    values = request.get_json()</p>
<pre><code># Check that the required fields are in the POST&apos;ed data
required = \[&apos;sender&apos;, &apos;recipient&apos;, &apos;amount&apos;\]
if not all(k in values for k in required):
    return &apos;Missing values&apos;, 400

# Create a new Transaction
index = blockchain.new_transaction(values\[&apos;sender&apos;\], values\[&apos;recipient&apos;\], values\[&apos;amount&apos;\])

response = {&apos;message&apos;: f&apos;Transaction will be added to Block {index}&apos;}
return jsonify(response), 201
</code></pre><hr>
<h4 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h4><p>挖矿正是神奇所在，它很简单，做了一下三件事：</p>
<ol>
<li>计算工作量证明 PoW</li>
<li>通过新增一个交易授予矿工（自己）一个币</li>
<li>构造新区块并将其添加到链中</li>
</ol>
<p><em>blockchain.py</em></p>
<p>import hashlib<br>import json</p>
<p>from time import time<br>from uuid import uuid4</p>
<p>from flask import Flask, jsonify, request</p>
<p>…</p>
<p>@app.route(‘/mine’, methods=[‘GET’])<br>def mine():</p>
<pre><code># We run the proof of work algorithm to get the next proof...
last\_block = blockchain.last\_block
last\_proof = last\_block\[&apos;proof&apos;\]
proof = blockchain.proof\_of\_work(last_proof)

# We must receive a reward for finding the proof.
# The sender is &quot;0&quot; to signify that this node has mined a new coin.
blockchain.new_transaction(
    sender=&quot;0&quot;,
    recipient=node_identifier,
    amount=1,
)

# Forge the new Block by adding it to the chain
previous\_hash = blockchain.hash(last\_block)
block = blockchain.new\_block(proof, previous\_hash)

response = {
    &apos;message&apos;: &quot;New Block Forged&quot;,
    &apos;index&apos;: block\[&apos;index&apos;\],
    &apos;transactions&apos;: block\[&apos;transactions&apos;\],
    &apos;proof&apos;: block\[&apos;proof&apos;\],
    &apos;previous\_hash&apos;: block\[&apos;previous\_hash&apos;\],
}
return jsonify(response), 200
</code></pre><p>注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕 Blockchain 类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下。</p>
<hr>
<h3 id="Step-3-运行区块链"><a href="#Step-3-运行区块链" class="headerlink" title="Step 3: 运行区块链"></a>Step 3: 运行区块链</h3><p>你可以使用 cURL 或 Postman 去和 API 进行交互 启动 Server：</p>
<p>$ python blockchain.py<br>* Running on <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</p>
<p>让我们通过请求 <a href="http://localhost:5000/mine" target="_blank" rel="noopener">http://localhost:5000/mine</a> （ GET ）来进行挖矿： <img src="https://pythoncaffcdn.phphub.org/uploads/images/201801/10/1/XocCyBrwu5.png" alt="挖矿"> 用 Postman 发起一个 GET 请求. 创建一个交易请求，请求 <a href="http://localhost:5000/transactions/new" target="_blank" rel="noopener">http://localhost:5000/transactions/new</a> （POST）,如图 <img src="https://pythoncaffcdn.phphub.org/uploads/images/201801/10/1/0FhWFFwqhI.png" alt=""> 如果不是使用 Postman，则用一下的 cURL 语句也是一样的：</p>
<p>$ curl -X POST -H “Content-Type: application/json” -d ‘{<br> “sender”: “d4ee26eee15148ee92c6cd394edd974e”,<br> “recipient”: “someone-other-address”,<br> “amount”: 5<br>}’ “<a href="http://localhost:5000/transactions/new&quot;" target="_blank" rel="noopener">http://localhost:5000/transactions/new&quot;</a></p>
<p>在挖了两次矿之后，就有 3 个块了，通过请求 <a href="http://localhost:5000/chain" target="_blank" rel="noopener">http://localhost:5000/chain</a> 可以得到所有的块信息</p>
<p>{<br>  “chain”: [<br>    {<br>      “index”: 1,<br>      “previous_hash”: 1,<br>      “proof”: 100,<br>      “timestamp”: 1506280650.770839,<br>      “transactions”: []<br>    },<br>    {<br>      “index”: 2,<br>      “previous_hash”: “c099bc…bfb7”,<br>      “proof”: 35293,<br>      “timestamp”: 1506280664.717925,<br>      “transactions”: [<br>        {<br>          “amount”: 1,<br>          “recipient”: “8bbcb347e0634905b0cac7955bae152b”,<br>          “sender”: “0”<br>        }<br>      ]<br>    },<br>    {<br>      “index”: 3,<br>      “previous_hash”: “eff91a…10f2”,<br>      “proof”: 35089,<br>      “timestamp”: 1506280666.1086972,<br>      “transactions”: [<br>        {<br>          “amount”: 1,<br>          “recipient”: “8bbcb347e0634905b0cac7955bae152b”,<br>          “sender”: “0”<br>        }<br>      ]<br>    }<br>  ],<br>  “length”: 3<br>}</p>
<hr>
<h3 id="Step-4-一致性（共识）"><a href="#Step-4-一致性（共识）" class="headerlink" title="Step 4: 一致性（共识）"></a>Step 4: 一致性（共识）</h3><p>我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法</p>
<h4 id="注册节点"><a href="#注册节点" class="headerlink" title="注册节点"></a>注册节点</h4><p>在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：</p>
<ol>
<li><code>/nodes/register</code> 接收 URL 形式的新节点列表.</li>
<li><code>/nodes/resolve</code> 执行一致性算法，解决任何冲突，确保节点拥有正确的链.</li>
</ol>
<p>我们修改下 Blockchain 的 init 函数并提供一个注册节点方法： <em>blockchain.py</em></p>
<p>…<br>from urllib.parse import urlparse<br>…</p>
<p>class Blockchain(object):<br>    def __init__(self):<br>        …<br>        self.nodes = set()<br>        …</p>
<pre><code>def register_node(self, address):
    &quot;&quot;&quot;
    Add a new node to the list of nodes
    :param address: &lt;str&gt; Address of node. Eg. &apos;http://192.168.0.5:5000&apos;
    :return: None
    &quot;&quot;&quot;

    parsed_url = urlparse(address)
    self.nodes.add(parsed_url.netloc)
</code></pre><p>我们用 set 来储存节点，这是一种避免重复添加节点的简单方法.</p>
<hr>
<h4 id="实现共识算法"><a href="#实现共识算法" class="headerlink" title="实现共识算法"></a>实现共识算法</h4><p>就像先前讲的那样，当一个节点与另一个节点有不同的链时，就会产生冲突。 为了解决这个问题，我们将制定最长的有效链条是最权威的规则。换句话说就是：在这个网络里最长的链就是最权威的。 我们将使用这个算法，在网络中的节点之间达成共识。 <em>blockchain.py</em></p>
<p>…<br>import requests</p>
<p>class Blockchain(object)<br>    …</p>
<pre><code>def valid_chain(self, chain):
    &quot;&quot;&quot;
    Determine if a given blockchain is valid
    :param chain: &lt;list&gt; A blockchain
    :return: &lt;bool&gt; True if valid, False if not
    &quot;&quot;&quot;

    last_block = chain\[0\]
    current_index = 1

    while current_index &lt; len(chain):
        block = chain\[current_index\]
        print(f&apos;{last_block}&apos;)
        print(f&apos;{block}&apos;)
        print(&quot;\\n-----------\\n&quot;)
        # Check that the hash of the block is correct
        if block\[&apos;previous\_hash&apos;\] != self.hash(last\_block):
            return False

        # Check that the Proof of Work is correct
        if not self.valid\_proof(last\_block\[&apos;proof&apos;\], block\[&apos;proof&apos;\]):
            return False

        last_block = block
        current_index += 1

    return True

def resolve_conflicts(self):
    &quot;&quot;&quot;
    This is our Consensus Algorithm, it resolves conflicts
    by replacing our chain with the longest one in the network.
    :return: &lt;bool&gt; True if our chain was replaced, False if not
    &quot;&quot;&quot;

    neighbours = self.nodes
    new_chain = None

    # We&apos;re only looking for chains longer than ours
    max_length = len(self.chain)

    # Grab and verify the chains from all the nodes in our network
    for node in neighbours:
        response = requests.get(f&apos;http://{node}/chain&apos;)

        if response.status_code == 200:
            length = response.json()\[&apos;length&apos;\]
            chain = response.json()\[&apos;chain&apos;\]

            # Check if the length is longer and the chain is valid
            if length &gt; max\_length and self.valid\_chain(chain):
                max_length = length
                new_chain = chain

    # Replace our chain if we discovered a new, valid chain longer than ours
    if new_chain:
        self.chain = new_chain
        return True

    return False
</code></pre><p>第一个方法 <code>valid_chain()</code> 负责检查一个链是否有效，方法是遍历每个块并验证散列和证明。 <code>resolve_conflicts()</code> 是一个遍历我们所有邻居节点的方法，下载它们的链并使用上面的方法验证它们。 如果找到一个长度大于我们的有效链条，我们就取代我们的链条。 我们将两个端点注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突： <em>blockchain.py</em></p>
<p>@app.route(‘/nodes/register’, methods=[‘POST’])<br>def register_nodes():<br>    values = request.get_json()</p>
<pre><code>nodes = values.get(&apos;nodes&apos;)
if nodes is None:
    return &quot;Error: Please supply a valid list of nodes&quot;, 400

for node in nodes:
    blockchain.register_node(node)

response = {
    &apos;message&apos;: &apos;New nodes have been added&apos;,
    &apos;total_nodes&apos;: list(blockchain.nodes),
}
return jsonify(response), 201
</code></pre><p>@app.route(‘/nodes/resolve’, methods=[‘GET’])<br>def consensus():<br>    replaced = blockchain.resolve_conflicts()</p>
<pre><code>if replaced:
    response = {
        &apos;message&apos;: &apos;Our chain was replaced&apos;,
        &apos;new_chain&apos;: blockchain.chain
    }
else:
    response = {
        &apos;message&apos;: &apos;Our chain is authoritative&apos;,
        &apos;chain&apos;: blockchain.chain
    }

return jsonify(response), 200
</code></pre><hr>
<p>在这一点上，如果你喜欢，你可以使用一台不同的机器，并在你的网络上启动不同的节点。 或者使用同一台机器上的不同端口启动进程。 我在我的机器上，不同的端口上创建了另一个节点，并将其注册到当前节点。 因此，我有两个节点：<code>http://localhost:5000</code> 和 <code>http://localhost:5001</code>。 注册一个新节点： <img src="https://pythoncaffcdn.phphub.org/uploads/images/201801/10/1/PCmpK0KOtn.png" alt=""> 然后我在节点 2 上挖掘了一些新的块，以确保链条更长。 之后，我在节点1上调用 <code>GET /nodes/resolve</code>，其中链由一致性算法取代： <img src="https://pythoncaffcdn.phphub.org/uploads/images/201801/10/1/dymRRmwPnx.png" alt=""> 这是一个包，去找一些朋友一起，以帮助测试你的区块链。</p>
<hr>
<p>我之所以对数字货币入迷，是因为我相信区块链会很快改变我们看待事物的方式，包括经济、政府、档案管理等。在我看来，目前的区块链就像90年代的互联网一样，正处于萌芽期，在不远的将来，区块链必将颠覆许多行业的传统运作方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/06/learn-blockchains-by-building-one/" data-id="cjqn5ydmx000c0wuul4y7xu48" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchains/">blockchains</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jubi" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/jubi/" class="article-date">
  <time datetime="2018-02-05T17:25:54.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-currency/">Digital currency</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/jubi/">一个不幸夭折的虚拟货币自动套利策略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2017年无疑是虚拟货币的元年，整体市值已经突破了四万亿人民币。上涨几百倍几千倍的山寨币比比皆是，即使这种行情，能拿到这么多倍数的人少之又少，而且也还有很多人是亏损的，毕竟虚拟货币的波动太大，分分钟让人怀疑人生。 所以虚拟货币是一种收益高风险也高的投资。除了投资和投机之外，在虚拟货币的市场也产生了许多其他获利的方式，比如<strong>搬砖、量化交易</strong>等。这里介绍一种在聚币网用程序<em>自动交易</em>的策略。 <em>聚币网（<a href="http://jubi.com" target="_blank" rel="noopener">jubi.com</a>）</em>，在2017年九月之前，在国内币圈号称“聚币小赌场”。每天零点整，平台上都会有几个山寨币被暴力拉升，<strong>少则几十点，多则数倍</strong>。所以每天都有人埋伏这些各种山寨币，碰运气，小赌场的名号由此而来。然而，不幸的是九月份ZF开始管制国内的虚拟货币交易，关停所有交易所，小赌场也未能幸免，所以这个策略也随之夭折了。 小赌场每晚暴力拉升的时间非常短，几秒几十秒就能完成，庄家出货也非常快。如果每晚守在电脑前，看见有极速拉升的币种立即买入然后出货，八成会被套。。。 既然无法手动交易，那么不妨设计一个策略让程序去自动买卖。这个策略分为三个部分，检测被拉升的币种、挂单买入、出货。</p>
<h4 id="一、检测被拉升的币种"><a href="#一、检测被拉升的币种" class="headerlink" title="一、检测被拉升的币种"></a>一、检测被拉升的币种</h4><p>首先介绍一下聚币的<a href="https://www.jubi.com/help/api.html" target="_blank" rel="noopener">API</a>，我们可以通过调用API来获取行情、查询账户信息以及进行交易等。 [caption id=”” align=”aligncenter” width=”647”]<img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/TIM%E6%88%AA%E5%9B%BE20180205235240.jpg" alt=""> 图 聚币API介绍[/caption] 这里使用python来调用API以实现各种功能，后面附详细代码。 聚币网涨跌幅参照每晚零点的价格计算的，所以可以通过每晚零点的实时涨跌幅来检测是否有被拉升的币种。 判断条件是：</p>
<ul>
<li>涨幅最高的币在5%-10%之间</li>
<li>有多于10个币种涨跌幅为0</li>
<li>当前时间在0:00 - 0:01之间</li>
</ul>
<p>满足上述条件，基本可以认为有狗庄在拉升当前涨幅最高的币种。 当然，在具体操作的时候并没有想象的那么容易，就比如聚币的API有一些坑：</p>
<ul>
<li>使用公钥、私钥和签名进行认证时，需要按照一定的顺序（signature,nonce,key，nonce参数一定要在key前面）才能成功通过验证，这点在官方文档中并未提及。最后是给写过类似博客的一位dalao发邮件询问得知的，在此感谢。</li>
<li>还一点让人百思不得其解，聚币并没有提供获取当前涨跌幅的API，后来反复对比浏览器加载数据时向服务器请求的url，找到了一个并未写在文档中的url（<a href="https://www.jubi.com/coin/trends），通过这个url请求的数据是每个币种的历史价格，当然也包括前一天的收盘价格，涨跌幅随之也能计算。" target="_blank" rel="noopener">https://www.jubi.com/coin/trends），通过这个url请求的数据是每个币种的历史价格，当然也包括前一天的收盘价格，涨跌幅随之也能计算。</a></li>
<li>……</li>
</ul>
<h4 id="二、挂单买入"><a href="#二、挂单买入" class="headerlink" title="二、挂单买入"></a>二、挂单买入</h4><p>经过第一步获取到可以投机的币种，接下来便是快速买入。 应该以什么价格买入？我这里采用的策略是挂高于当前价格20%的单买入，原因如下：</p>
<ul>
<li>鉴于狗庄的拉升是迅速的，若我获取到当前的价格后，立即以该价格挂单，这样八成是买不到的，因为这中间有一来一回的数据请求过程，网络延迟就有几十甚至上百毫秒，价格肯定已经更高了。</li>
<li>平台交易系统的成交规则是买一卖一价成交。举个例子，btc当前的卖一价是$3000、数量1个，卖二价是$3100、数量1个，卖三价是$4000、数量2个，那么当以$4000的价格挂单买入1.5个btc时，最终成交情况是$3000成交1个、$3100成交0.5个，而非$4000成交1.5个。所以，挂高于当前价格20%的单能以当前的最低卖价成交，而又不至于买不到。</li>
</ul>
<p>[caption id=”” align=”aligncenter” width=”690”]<img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/TIM%E6%88%AA%E5%9B%BE20180206013821.jpg" alt=""> 测试时的一次自动交易记录（自动买入，手动卖出）[/caption]</p>
<h4 id="三、出货"><a href="#三、出货" class="headerlink" title="三、出货"></a>三、出货</h4><p>考虑到庄家出货需要一定的时间，最初是考虑人工出货的，不使用程序。 测试时发现，人工手动出货容易受到情绪以及心态的影响，一不小心就能从盈利变为亏损，所以后面决定采用程序自动出货（最终并没有投入使用）。 出货条件是一旦检测到买入的币种价格开始下跌便全部卖出，挂单价格是第二步的成交价格。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个策略是17年八月底到九月初萌生并开始实现的（拖了半年才写出这篇23333），起初只实现了前两个部分。经过几个晚上的测试，程序能够很好的按照策略执行，还没等实现第三个部分，zf发了个文件<a href="http://www.pbc.gov.cn/goutongjiaoliu/113456/113469/3374222/index.html" target="_blank" rel="noopener">《中国人民银行 中央网信办 工业和信息化部 工商总局 银监会 证监会 保监会关于防范代币发行融资风险的公告》</a>，监管虚拟货币市场，并关停国内各大交易所，聚币网也就这样被关停了。。。 <img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/TIM%E6%88%AA%E5%9B%BE20180206011022.jpg" alt="">     虽然这个策略被扼杀在了摇篮中，但我奔向温饱的梦想是永远无法被扼杀的，哈哈哈。 最近一直在琢磨量化交易的策略，也封装了一些平台的原始API，并实现了一个量化交易，每天自动交易2w到3w次左右，但盈利率比较低。 所以如果有什么想法和策略尽情联系我，我们一起走向温饱哈哈。      </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面是一些用python封装的API。 login.py</p>
<p># -<em>- coding: utf-8 -</em>-</p>
<p>“””<br>成功请求的参数顺序：<br>signature,nonce,key<br>nonce,        ,key<br>(nonce参数一定要在key前面)<br>“””</p>
<p>import requests<br>import time<br>import hashlib<br>import hmac<br>import collections<br>import urllib<br>import urllib2</p>
<p>class Jubi(object):</p>
<pre><code>def \_\_init\_\_(self, public\_key, private\_key):
    self.public\_key = public\_key
    self.private\_key = private\_key

def get_nonce(self):
    curr_stamp = time.time()*100
    nonce = int(curr_stamp)
    return nonce

def get_md5(self,s):
    m = hashlib.md5()
    m.update(s.encode())
    return m.hexdigest()

def get_params(self):
    nonce\_value = self.get\_nonce()
    key\_value = self.public\_key
    private\_key = self.private\_key
    string = (&apos;nonce=&apos; + str(nonce\_value) + &apos;&amp;&apos; + &apos;key=&apos; + key\_value).encode(&apos;utf-8&apos;)
    private\_key\_md5 = self.get\_md5(private\_key).encode(&apos;utf-8&apos;)
    signature = hmac.new(private\_key\_md5, string, digestmod=hashlib.sha256).hexdigest()
    dict_ordered = collections.OrderedDict()
    dict_ordered\[&apos;signature&apos;\] = signature
    dict\_ordered\[&apos;nonce&apos;\] = nonce\_value
    dict\_ordered\[&apos;key&apos;\] = key\_value
    return dict_ordered

def get\_trade\_list_params(self, since, coin, type):
    nonce\_value = self.get\_nonce()
    key\_value = self.public\_key
    private\_key = self.private\_key
    string = (&apos;nonce=&apos; + str(nonce\_value) + &apos;&amp;&apos; + &apos;key=&apos; + key\_value + &apos;&amp;since=&apos; + str(since) + &apos;&amp;coin=&apos; + coin + &apos;&amp;type=&apos; +type).encode(&apos;utf-8&apos;)
    private\_key\_md5 = self.get\_md5(private\_key).encode(&apos;utf-8&apos;)
    signature = hmac.new(private\_key\_md5, string, digestmod=hashlib.sha256).hexdigest()
    dict_ordered = collections.OrderedDict()
    dict_ordered\[&apos;signature&apos;\] = signature
    dict\_ordered\[&apos;nonce&apos;\] = nonce\_value
    dict\_ordered\[&apos;key&apos;\] = key\_value
    dict_ordered\[&apos;since&apos;\] = since
    dict_ordered\[&apos;coin&apos;\] = coin
    dict_ordered\[&apos;type&apos;\] = type
    return dict_ordered

def get\_trade\_view_params(self, id, coin):
    nonce\_value = self.get\_nonce()
    key\_value = self.public\_key
    private\_key = self.private\_key
    string = (&apos;nonce=&apos; + str(nonce\_value) + &apos;&amp;&apos; + &apos;key=&apos; + key\_value + &apos;&amp;id=&apos; + str(id) + &apos;&amp;coin=&apos; + coin).encode(&apos;utf-8&apos;)
    private\_key\_md5 = self.get\_md5(private\_key).encode(&apos;utf-8&apos;)
    signature = hmac.new(private\_key\_md5, string, digestmod=hashlib.sha256).hexdigest()
    dict_ordered = collections.OrderedDict()
    dict_ordered\[&apos;signature&apos;\] = signature
    dict\_ordered\[&apos;nonce&apos;\] = nonce\_value
    dict\_ordered\[&apos;key&apos;\] = key\_value
    dict_ordered\[&apos;id&apos;\] = id
    dict_ordered\[&apos;coin&apos;\] = coin
    return dict_ordered

def get\_trade\_add_params(self, amount, price, type, coin):
    nonce\_value = self.get\_nonce()
    key\_value = self.public\_key
    private\_key = self.private\_key
    string = (&apos;nonce=&apos; + str(nonce\_value) + &apos;&amp;key=&apos; + key\_value + &apos;&amp;amount=&apos; + str(amount) +&apos;&amp;price=&apos; +str(price) +&apos;&amp;type=&apos; +type +&apos;&amp;coin=&apos;+coin).encode(&apos;utf-8&apos;)
    #string = &quot;amount=&quot;+str(amount)+&quot;&amp;nonce=&quot;+str(nonce\_value)+&quot;&amp;type=&quot;+type+&quot;&amp;key=&quot;+key\_value+&quot;&amp;price=&quot;+str(price)+&quot;&amp;coin=&quot;+coin
    private\_key\_md5 = self.get\_md5(private\_key).encode(&apos;utf-8&apos;)
    signature = hmac.new(private\_key\_md5, string, digestmod=hashlib.sha256).hexdigest()

    dict_ordered = collections.OrderedDict()
    dict_ordered\[&apos;signature&apos;\] = signature
    dict\_ordered\[&apos;nonce&apos;\] = nonce\_value
    dict\_ordered\[&apos;key&apos;\] = key\_value
    dict_ordered\[&apos;amount&apos;\] = amount
    dict_ordered\[&apos;price&apos;\] = price
    dict_ordered\[&apos;type&apos;\] = type
    dict_ordered\[&apos;coin&apos;\] = coin

    return dict_ordered
</code></pre><p>ticker.py</p>
<p># -<em>- coding: utf-8 -</em>-</p>
<p>import requests<br>import time<br>import login<br>import urllib2<br>import json</p>
<p>class ticker(object):</p>
<pre><code>def \_\_init\_\_(self, coin):
    self.url = &apos;https://www.jubi.com/api/v1/ticker/&apos;
    self.coin = coin

def get\_coin\_ticker(self):
    self.resp = requests.post(url = self.url, data = {&apos;coin&apos;: self.coin}).json()
    response = urllib2.urlopen(&apos;https://www.jubi.com/coin/trends&apos;)
    html = response.read().decode(&quot;utf8&quot;,&quot;ignore&quot;).encode(&quot;gbk&quot;,&quot;ignore&quot;)
    trends = json.loads(html)

    self.resp\[&apos;yprice&apos;\] = trends\[self.coin\]\[&apos;yprice&apos;\]

    last = self.resp\[&apos;last&apos;\].encode(&quot;utf-8&quot;)    #unicode to string
    self.resp\[&apos;last&apos;\] = float(last)                #string to float
    buy = self.resp\[&apos;buy&apos;\].encode(&quot;utf-8&quot;)
    self.resp\[&apos;buy&apos;\] = float(buy)
    sell = self.resp\[&apos;sell&apos;\].encode(&quot;utf-8&quot;)
    self.resp\[&apos;sell&apos;\] = float(sell)
    high = self.resp\[&apos;high&apos;\].encode(&quot;utf-8&quot;)
    self.resp\[&apos;high&apos;\] = float(high)
    low = self.resp\[&apos;low&apos;\].encode(&quot;utf-8&quot;)
    self.resp\[&apos;low&apos;\] = float(low)

    if self.resp\[&apos;yprice&apos;\] != 0:        
        self.resp\[&apos;rate&apos;\] = (self.resp\[&apos;last&apos;\]/self.resp\[&apos;yprice&apos;\]) - 1
    else:
        self.resp\[&apos;rate&apos;\] = -1.0
    return self.resp

def calc\_all\_rate(self):
    allTicker = self.get_allTicker()
    #print allTicker
    self.zero_num = 0
    headers = {&apos;User-agent&apos; : &apos;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0&apos;}

    request = urllib2.Request(&apos;https://www.jubi.com/coin/trends&apos;, headers = headers)
    response = urllib2.urlopen(request)
    #response = urllib2.urlopen(&apos;https://www.jubi.com/coin/trends&apos;)
    html = response.read().decode(&quot;utf8&quot;,&quot;ignore&quot;).encode(&quot;gbk&quot;,&quot;ignore&quot;)
    trends = json.loads(html)
    for coin in trends:
        coin_yprice = trends\[coin\]\[&apos;yprice&apos;\]
        allTicker\[coin\]\[&apos;yprice&apos;\] = coin_yprice

        if coin_yprice != 0:
            allTicker\[coin\]\[&apos;rate&apos;\] = round(allTicker\[coin\]\[&apos;last&apos;\]/coin_yprice - 1, 4)
        else:
            allTicker\[coin\]\[&apos;rate&apos;\] = -1.0000
        if allTicker\[coin\]\[&apos;rate&apos;\] == 0:
            self.zero_num += 1
    #print self.zero_num
        #print coin , allTicker\[coin\]\[&apos;rate&apos;\]\
    return allTicker

def sort\_by\_rate(self):
    allTicker = self.calc\_all\_rate()
    #print allTicker
    #for coin in allTicker:
    #    backitems = \[allTicker\[coin\]\[&apos;rate&apos;\], coin\]
    self.backitems=\[\[allTicker\[coin\]\[&apos;rate&apos;\],coin\] for coin in allTicker\]
    self.backitems.sort(reverse = True)
    &apos;&apos;&apos;for i in range(0, len(backitems)):
        print backitems\[i\]&apos;&apos;&apos;
    return self.backitems

def print_ticker(self):
    for i in range(0, len(self.backitems)):
        print self.backitems\[i\]

def get_allTicker(self):
    url = &apos;https://www.jubi.com/api/v1/allticker/&apos;
    result = requests.post(url = url).json()
    return result

def get_orders(self):
    url = &apos;https://www.jubi.com/api/v1/orders/&apos;
    result = requests.post(url = url, data = self.coin).json()
    return result
</code></pre><p>  trade.py</p>
<p># -<em>- coding: utf-8 -</em>-</p>
<p>import requests<br>import time<br>import login</p>
<p>class trade(object):</p>
<pre><code>def \_\_init\_\_(self, account):
    self.account = account

def get\_trade\_list(self, since, coin, type):
    params = self.account.get\_trade\_list_params(since, coin, type)
    url = &apos;https://www.jubi.com/api/v1/trade_list/&apos;
    self.list = requests.post(url = url, data = params).json()
    return self.list

def get\_trade\_view(self, id, coin):
    params = self.account.get\_trade\_view_params(id, coin)
    url = &apos;https://www.jubi.com/api/v1/trade_view/&apos;
    self.view = requests.post(url = url, data = params).json()
    return self.view

def trade_cancel(self, id, coin):
    params = self.account.get\_trade\_view_params(id, coin)
    url = &apos;https://www.jubi.com/api/v1/trade_cancel/&apos;
    self.cancel = requests.post(url = url, data = params).json()
    return self.cancel

def trade_add(self, amount, price, type, coin):
    params = self.account.get\_trade\_add_params(amount, price, type, coin)
    #print params
    url = &apos;https://www.jubi.com/api/v1/trade_add/&apos;
    self.add = requests.post(url = url, data = params).json()
    #print self.add
    return self.add
</code></pre><p>balance.py</p>
<p># -<em>- coding: utf-8 -</em>-</p>
<p>import requests<br>import time<br>import login</p>
<p>class balance(object):</p>
<pre><code>def \_\_init\_\_(self, account):
    self.account = account
    self.url = &apos;https://www.jubi.com/api/v1/balance/&apos;
    self.data = self.account.get_params()
    self.resp = requests.post(url = self.url, data = self.data).json()

def get\_all\_balances(self):
    return self.resp

def get_asset(self):
    return self.resp\[&apos;asset&apos;\]

def get\_coin\_balances(self, coin):
    #Coin\_balance = coin + &apos;\_balance&apos;
    #Coin\_lock = coin + &apos;\_lock&apos;
    coin\_balances = {&apos;balance&apos; : self.get\_coin\_balance(coin), &apos;lock&apos; : self.get\_coin_lock(coin)}
    return coin_balances                

def get\_coin\_balance(self, coin):
    Coin = coin + &apos;_balance&apos;
    return self.resp\[Coin\]

def get\_coin\_lock(self, coin):
    Coin = coin + &apos;_lock&apos;
    return self.resp\[Coin\]
</code></pre><p>  其他交易平台API的使用方法类似于此</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/06/jubi/" data-id="cjqn5ydmv000b0wuuw1w15ivn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Digital-currency/">Digital currency</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ecnu-library" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/ecnu-library/" class="article-date">
  <time datetime="2018-02-05T13:39:37.000Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ECNU/">ECNU</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/ecnu-library/">关于华师大图书馆创意空间预约系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://202.120.82.2:8081/ClientWeb/xcus/ic2/Default.aspx" target="_blank" rel="noopener">学校图书馆创意空间预约系统</a> ↓↓ <img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/3.png" alt=""> 从URL中看到使用的是GET方法，可以分析出API格式。 写个脚本，处理下服务器返回的数据，能提取出如下数据。 [caption id=”” align=”alignnone” width=”676”]<img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/5.png" alt=""> （20171122全天的预约情况，预约人、时间、房间号等一览无余）[/caption]   [caption id=”” align=”alignnone” width=”675”]<img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/6.png" alt=""> （上图是20171119 21:30左右查询的当天的预约情况，未显示已失效的预约）[/caption]   这些API照理说应该有个身份认证过程，没有权限的用户无法获取数据，结果…… 同样，改一下GET的数据就能写个自动抢小包间的脚本了，不再赘述。   （另外，经过很长一段时间对预约情况的观察，发现其实有人每天都在用脚本抢23333） 仔细深究下去，这网站的bug还有很多…比如通过这个预约系统可以根据一位同学或者老师的姓名(或姓名的一部分）查到对应的学号、工号，进而就有了全校每个人的联系方式等等…2333     <img src="http://gaojx-1253732420.cossh.myqcloud.com/%E7%B4%A0%E6%9D%90/8.jpg" alt="">   纯粹出于兴趣和吐槽….</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/05/ecnu-library/" data-id="cjqn5ydmc00000wuu0nlmkjsu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECNU/">ECNU</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchains/">Blockchains</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blockchains/Digital-currency/">Digital currency</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Capriccio/">Capriccio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataAnalysis/">DataAnalysis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digital-currency/">Digital currency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ECNU/">ECNU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataAnalysis/">DataAnalysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Digital-currency/">Digital currency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECNU/">ECNU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SeamCarving/">SeamCarving</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchains/">blockchains</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DataAnalysis/" style="font-size: 15px;">DataAnalysis</a> <a href="/tags/Digital-currency/" style="font-size: 15px;">Digital currency</a> <a href="/tags/ECNU/" style="font-size: 10px;">ECNU</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/SeamCarving/" style="font-size: 10px;">SeamCarving</a> <a href="/tags/blockchains/" style="font-size: 15px;">blockchains</a> <a href="/tags/python/" style="font-size: 20px;">python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/08/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/06/26/seamcarving/">图像接缝剪裁SeamCarving的实现</a>
          </li>
        
          <li>
            <a href="/2018/05/06/sklearn-predict-typhoon/">使用Sklearn训练模型预测台风路径</a>
          </li>
        
          <li>
            <a href="/2018/04/16/virtual-currency-automatic-trading-data/">关于通过脚本实现虚拟货币量化交易的部分交易数据（17w+条）</a>
          </li>
        
          <li>
            <a href="/2018/04/16/mysql-python-week-number/">关于mysql和python跨年周以及当前周的计算问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>